package practices;

import java.util.Hashtable;
import java.util.Stack;


public class LinkedListNode {

	LinkedListNode next = null;
	int data;

	public LinkedListNode(int d) {
		data = d;
	}

	public LinkedListNode(int carry, LinkedListNode l1, LinkedListNode l2) {
		data = carry;
	}

	// adds element to the end of the list
	public void appendToTail(int d) {
		LinkedListNode end = new LinkedListNode(d);
		LinkedListNode n = this;
		while (n.next != null) {
			n = n.next;
		}
		n.next = end;
	}

	public static LinkedListNode deleteLinkedListNode(LinkedListNode head, int d) {
		LinkedListNode n = head;

		if (n.data == d) {
			return head.next; // moved to head.
		}

		while (n.next != null) {
			if (n.next.data == d) {
				n.next = n.next.next;
				return head; // head didnt chanage
			}
		}
		return head;
	}

	// Just displays the data, by traversing through the list.
	public static void display(LinkedListNode n) {
		LinkedListNode current = n;

		while (current != null) {
			if (current.next == null) {
				System.out.print(current.data);

			} else {
				System.out.print(current.data + " --> ");
			}
			current = current.next;
		}
	}

	// Solution with HashTable and temp buffer allow
	public static void removeDups(LinkedListNode n) {
		Hashtable table = new Hashtable();
		LinkedListNode prev = null;

		while (n != null) {
			if (table.containsKey(n.data)) {
				prev.next = n.next;
			} else {
				table.put(n.data, true);
				prev = n;
			}
			n = n.next;
		}
	}

	public static void removeDupsNoB(LinkedListNode n) {
		if (n == null) {
			return;
		}
		LinkedListNode current = n; // starts at the head

		while (current != null) {
			LinkedListNode runner = current;

			while (runner.next != null) {
				if (runner.next.data == current.data) {
					runner.next = runner.next.next;
				} else {
					runner = runner.next;
				}
			}
			current = current.next;
		}
	}

	// 2.2
	public static int nthToLastSize(LinkedListNode head, int k) {
		if (head == null) {
			return 0;
		}

		int i = (nthToLastSize(head.next, k)) + 1;

		if (i == k) {
			System.out.println(head.data);
		}
		return i;
	}

	// 2.3 delete a node

	public static boolean deleteNode(LinkedListNode n) {
		if (n == null || n.next == null)
			return false;

		LinkedListNode next = n.next;
		n.data = next.data;
		n.next = next.next;

		return true;
	}

	// 2.4 partition list
	public static LinkedListNode partition(LinkedListNode n, int x) {
		LinkedListNode beforeX = null;
		LinkedListNode afterX = null;

		while (n != null) {
			LinkedListNode next = n.next;
			if (n.data < 0) {
				n.next = beforeX;
				beforeX = n;
			} else {
				n.next = afterX;
				afterX = n;
			}
			n = n.next;
		}

		if (beforeX == null)
			return afterX;

		// Find end of before list and merge to beginning of after

		LinkedListNode head = beforeX;
		while (beforeX.next != null) {
			beforeX = beforeX.next;
		}

		beforeX.next = afterX;

		return head;
	}

	// 2.5 Summing linked list

	
	//2.6 Circular Linked List, using Fast Slow runner Algo,
	
	public static LinkedListNode findBeginning(LinkedListNode head){
		LinkedListNode slow,fast;
		fast = slow = head;
		
		// they will have to meet at one point in the loop
		while(fast != null || fast.next != null){
			slow = slow.next;
			fast = fast.next.next;
			
			if (slow == fast){
				break;
			}
		}
		
		if (fast == null || fast.next == null) return null;
		
		slow = head;
		
		// make them at the same pace.
		while(slow != fast){
			slow = slow.next;
			fast = fast.next;
		}
		
		return fast;
		
	}
		
	// 2.7 check if linked list is a palindrome (same word backwards)
	
	public static boolean isPalindrome(LinkedListNode head){
		LinkedListNode slow,fast;
		
		slow = fast = head;
		
		Stack<Integer> stack = new Stack<Integer>();
		
		return false;
	}
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
}
