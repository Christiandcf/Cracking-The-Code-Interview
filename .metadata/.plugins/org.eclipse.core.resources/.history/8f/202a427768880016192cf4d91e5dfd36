package treesNgraphs;

public class BinaryTree {
	
	public static void main(String[] args){
		System.out.println(recursion(4));
	}
	
	private class Node {
		private int value;
		private Node left;
		private Node right;
		

		public Node(int n){
			this.value = n;
		}
			
	}
	
	
	
	// 4.1
	public boolean isBalanced(Node n){
		if(balancedHeight(n) > 1) return true;
		return false;  
	}
	
	private int balancedHeight(Node n){
		if(n == null ) return 0;
		int h1 = balancedHeight(n.left);
		int h2 = balancedHeight(n.right);
		
		if ( h1 == -1 || h2 == -1) return -1;
		if (Math.abs(h1-h2) > 1) return -1;
		
		if (h1 >= h2) return h1 + 1;
		return h2 + 1;
	}
	
	 /*
	  * 4.3 we first find the middle of the array
	  * left of the tree will be less than the array
	  * right will be bigger, perform divide and conquer
	  * Similar to merge sort
	  */
	
	private Node minimalBST(int[] arr, int start, int end){
		
		if(end < start) return null;
		
		int mid = (end + start) / 2;
		
		Node n = new Node(arr[mid]);
	}
	
	static int recursion(int n){
		if (n == 1 ) return 1;
		return n * recursion(n - 1);
	}
	
}


